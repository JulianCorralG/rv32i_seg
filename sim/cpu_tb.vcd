$date
	Tue Nov 25 22:39:47 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module cpu_tb $end
$var wire 32 ! WriteData [31:0] $end
$var wire 32 " DataAdr [31:0] $end
$var reg 1 # clk $end
$var reg 1 $ reset $end
$scope module dut $end
$var wire 32 % DataAdr [31:0] $end
$var wire 32 & WriteData [31:0] $end
$var wire 1 # clk $end
$var wire 1 $ reset $end
$var wire 32 ' SrcB [31:0] $end
$var wire 32 ( SrcA [31:0] $end
$var wire 32 ) Result [31:0] $end
$var wire 32 * ReadData [31:0] $end
$var wire 1 + RUWr $end
$var wire 2 , RUDataWrSrc [1:0] $end
$var wire 32 - RD2 [31:0] $end
$var wire 32 . RD1 [31:0] $end
$var wire 32 / PC_Plus4 [31:0] $end
$var wire 32 0 PC_Next [31:0] $end
$var wire 32 1 PC_Current [31:0] $end
$var wire 1 2 PCSrc $end
$var wire 32 3 Instr [31:0] $end
$var wire 3 4 ImmSrc [2:0] $end
$var wire 32 5 ImmExt [31:0] $end
$var wire 1 6 DMWr $end
$var wire 3 7 DMCtrl [2:0] $end
$var wire 5 8 BrOp [4:0] $end
$var wire 32 9 ALUResult [31:0] $end
$var wire 4 : ALUOp [3:0] $end
$var wire 1 ; ALUBSrc $end
$var wire 1 < ALUASrc $end
$scope module alu $end
$var wire 32 = B [31:0] $end
$var wire 4 > ALUOp [3:0] $end
$var wire 32 ? A [31:0] $end
$var reg 32 @ ALURes [31:0] $end
$upscope $end
$scope module branch_unit $end
$var wire 1 2 NextPCSrc $end
$var wire 32 A RURs2 [31:0] $end
$var wire 32 B RURs1 [31:0] $end
$var wire 5 C BrOp [4:0] $end
$var reg 1 D BranchTaken $end
$upscope $end
$scope module control_unit $end
$var wire 3 E Funct3 [2:0] $end
$var wire 7 F Funct7 [6:0] $end
$var wire 7 G OpCode [6:0] $end
$var reg 1 < ALUASrc $end
$var reg 1 ; ALUBSrc $end
$var reg 4 H ALUOp [3:0] $end
$var reg 5 I BrOp [4:0] $end
$var reg 3 J DMCtrl [2:0] $end
$var reg 1 6 DMWr $end
$var reg 3 K ImmSrc [2:0] $end
$var reg 2 L RUDataWrSrc [1:0] $end
$var reg 1 + RUWr $end
$upscope $end
$scope module data_mem $end
$var wire 32 M Address_ALURes [31:0] $end
$var wire 3 N DMCtrl [2:0] $end
$var wire 1 6 DMWr $end
$var wire 10 O word_addr [9:0] $end
$var wire 2 P byte_offset [1:0] $end
$var wire 32 Q DataWr [31:0] $end
$var parameter 32 R MEM_SIZE_WORDS $end
$var reg 32 S DataRd [31:0] $end
$scope begin $unm_blk_17 $end
$var reg 32 T read_word [31:0] $end
$upscope $end
$upscope $end
$scope module imm_gen $end
$var wire 3 U ImmSrc [2:0] $end
$var wire 25 V Instr [31:7] $end
$var reg 32 W ImmExt [31:0] $end
$upscope $end
$scope module instr_mem $end
$var wire 32 X Instruction [31:0] $end
$var wire 32 Y Address_PC [31:0] $end
$var parameter 32 Z MEM_SIZE $end
$upscope $end
$scope module pc_module $end
$var wire 1 # clk $end
$var wire 1 $ reset $end
$var wire 32 [ PCOutput [31:0] $end
$var wire 32 \ NextPC [31:0] $end
$var reg 32 ] current_PC [31:0] $end
$upscope $end
$scope module pc_plus4_adder $end
$var wire 32 ^ PCOutput [31:0] $end
$var wire 32 _ AdderOutput [31:0] $end
$upscope $end
$scope module pcmux $end
$var wire 32 ` a [31:0] $end
$var wire 32 a b [31:0] $end
$var wire 1 2 sel $end
$var parameter 32 b WIDTH $end
$var reg 32 c y [31:0] $end
$upscope $end
$scope module reg_unit $end
$var wire 1 + RUWr $end
$var wire 5 d Rd [4:0] $end
$var wire 5 e Rs1 [4:0] $end
$var wire 5 f Rs2 [4:0] $end
$var wire 1 # clk $end
$var wire 32 g RURs2 [31:0] $end
$var wire 32 h RURs1 [31:0] $end
$var wire 32 i DataWr [31:0] $end
$upscope $end
$scope module result_mux $end
$var wire 32 j a [31:0] $end
$var wire 32 k b [31:0] $end
$var wire 32 l c [31:0] $end
$var wire 2 m sel [1:0] $end
$var parameter 32 n WIDTH $end
$var reg 32 o y [31:0] $end
$upscope $end
$scope module srca_mux $end
$var wire 32 p a [31:0] $end
$var wire 32 q b [31:0] $end
$var wire 1 < sel $end
$var parameter 32 r WIDTH $end
$var reg 32 s y [31:0] $end
$upscope $end
$scope module srcb_mux $end
$var wire 32 t a [31:0] $end
$var wire 32 u b [31:0] $end
$var wire 1 ; sel $end
$var parameter 32 v WIDTH $end
$var reg 32 w y [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100000 v
b100000 r
b100000 n
b100000 b
b10000000000 Z
b10000000000 R
$end
#0
$dumpvars
b0 w
b0 u
b0 t
b0 s
b0 q
b0 p
b0 o
b0 m
b100 l
bx k
b0 j
b0 i
b0 h
b0 g
b0 f
b0 e
b0 d
b100 c
b0 a
b100 `
b100 _
b0 ^
b0 ]
b100 \
b0 [
b0 Y
b10011 X
b0 W
b0 V
b0 U
bx T
bx S
b0 Q
b0 P
b0 O
b0 N
b0 M
b0 L
b0 K
b0 J
b0 I
b0 H
b10011 G
b0 F
b0 E
1D
b0 C
b0 B
b0 A
b0 @
b0 ?
b0 >
b0 =
0<
1;
b0 :
b0 9
b0 8
b0 7
06
b0 5
b0 4
b10011 3
02
b0 1
b100 0
b100 /
b0 .
b0 -
b0 ,
1+
bx *
b0 )
b0 (
b0 '
b0 &
b0 %
1$
0#
b0 "
b0 !
$end
#5
1#
#10
0#
0$
#15
bx *
bx S
bx k
b1 O
b1 P
b101 !
b101 &
b101 )
b101 i
b101 o
b101 "
b101 %
b101 9
b101 @
b101 M
b101 a
b101 j
xD
b101 '
b101 =
b101 w
b101 5
b101 W
b101 u
bx -
bx A
bx Q
bx g
bx t
b1010000000000001 V
b1 d
b101 f
b1000 0
b1000 \
b1000 c
b10100000000000010010011 3
b10100000000000010010011 X
b1000 /
b1000 _
b1000 `
b1000 l
b100 1
b100 Y
b100 [
b100 ]
b100 ^
b100 q
1#
#20
0#
#25
bx *
bx S
bx k
b10 O
b10 P
b1010 !
b1010 &
b1010 )
b1010 i
b1010 o
b1010 "
b1010 %
b1010 9
b1010 @
b1010 M
b1010 a
b1010 j
b1010 '
b1010 =
b1010 w
b1010 5
b1010 W
b1010 u
b10100000000000010 V
b10 d
b1010 f
b1100 0
b1100 \
b1100 c
b101000000000000100010011 3
b101000000000000100010011 X
b1100 /
b1100 _
b1100 `
b1100 l
b1000 1
b1000 Y
b1000 [
b1000 ]
b1000 ^
b1000 q
1#
#30
0#
#35
bx *
bx S
bx k
b11 O
b11 P
b1111 !
b1111 &
b1111 )
b1111 i
b1111 o
b1111 "
b1111 %
b1111 9
b1111 @
b1111 M
b1111 a
b1111 j
0D
b101 (
b101 ?
b101 s
b10 5
b10 W
b10 u
b1010 -
b1010 A
b1010 Q
b1010 g
b1010 t
b101 .
b101 B
b101 h
b101 p
0;
1+
b100000100000011 V
b11 d
b10 f
b1 e
b110011 G
b10000 0
b10000 \
b10000 c
b1000001000000110110011 3
b1000001000000110110011 X
b10000 /
b10000 _
b10000 `
b10000 l
b1100 1
b1100 Y
b1100 [
b1100 ]
b1100 ^
b1100 q
1#
#40
0#
#45
b0 *
b0 S
b0 k
bx O
bx P
bx !
bx &
bx )
bx i
bx o
bx "
bx %
bx 9
bx @
bx M
bx a
bx j
bx '
bx =
bx w
xD
bx (
bx ?
bx s
bx 5
bx W
bx u
bx -
bx A
bx Q
bx g
bx t
bx .
bx B
bx h
bx p
0+
bx V
bx d
bx f
bx e
bx E
bx F
bx G
b10100 0
b10100 \
b10100 c
bx 3
bx X
b10100 /
b10100 _
b10100 `
b10100 l
b10000 1
b10000 Y
b10000 [
b10000 ]
b10000 ^
b10000 q
1#
#50
0#
#55
b11000 0
b11000 \
b11000 c
b11000 /
b11000 _
b11000 `
b11000 l
b10100 1
b10100 Y
b10100 [
b10100 ]
b10100 ^
b10100 q
1#
#60
0#
#65
b11100 0
b11100 \
b11100 c
b11100 /
b11100 _
b11100 `
b11100 l
b11000 1
b11000 Y
b11000 [
b11000 ]
b11000 ^
b11000 q
1#
